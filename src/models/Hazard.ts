import { z } from 'zod';

const HazardSchema = z.object({
    id: z.number().int().positive().optional(),
    code: z.string()
        .min(1, 'Code is required')
        .max(25, 'Code must be 25 characters or less')
        .trim()
        .optional(), // Will be generated by trigger
    statusEn: z.enum(['Sent', 'On it', 'Solved', 'Rejected']).default('Sent'),
    statusMn: z.enum(['Илгээгдсэн', 'Ажиллаж байна', 'Шийдэгдсэн', 'Татгалзсан']).default('Илгээгдсэн'),
    user_id: z.number().int().positive('User ID must be a positive integer').nullable().optional(),
    user_name: z.string().max(320, 'User name must be 320 characters or less').nullable().optional(),
    email: z.string().email('Invalid email format').max(320, 'Email must be 320 characters or less').nullable().optional(),
    phone_number: z.string().length(8, 'Phone number must be exactly 8 digits').regex(/^\d{8}$/, 'Phone number must contain only digits').nullable().optional(),
    type_id: z.number().int().positive('Type ID must be a positive integer'), 
    location_id: z.number().int().positive('Location ID must be a positive integer'),
    description: z.string()
        .min(5, 'Description is required')
        .max(1000, 'Description must be 1000 characters or less')
        .trim(),
    solution: z.string()
        .min(1, 'Solution is required')
        .max(1000, 'Solution must be 1000 characters or less')
        .trim(),
    date_created: z.date().optional(), // Default SYSDATE
    has_image: z.number().int().refine(value => value === 0 || value === 1, {
        message: 'hasImage must be either 0 or 1'
    }),
});

function isEmpty(val: unknown) {
    return val == null || (typeof val === 'string' && val.trim() === '');
}

HazardSchema.refine((data) => {
    if (data.user_id != null) {
        // All must be empty
        return isEmpty(data.user_name) && isEmpty(data.email) && isEmpty(data.phone_number);
    }
    // All must be non-empty
    return !isEmpty(data.user_name) && !isEmpty(data.email) && !isEmpty(data.phone_number);
}, {
    message: 'Either user_id must be provided (with other fields empty), or ALL three fields (user_name, email, and phone_number) must be provided (with user_id empty)',
    path: ['user_id', 'user_name', 'email', 'phone_number']
});


type IHazardData = z.infer<typeof HazardSchema>;

// Schema for joined fields (expandable)
const HazardJoinedSchema = z.object({
    type_name_en: z.string().max(100).nullable().optional(),
    type_name_mn: z.string().max(100).nullable().optional(),
    location_name_en: z.string().max(100).nullable().optional(),
    location_name_mn: z.string().max(100).nullable().optional(),
    is_response_confirmed: z.number().nullable().optional(),
    response_body: z.string().nullable().optional(),
    is_private: z.number().nullable().optional(),
    date_updated: z.date().nullable().optional(),
    has_image: z.number().nullable().optional(),
});

type IHazardJoinedData = z.infer<typeof HazardJoinedSchema>;

export class Hazard implements IHazardData {
    static modelFor = {
        createRequest: {} as {
            user_id?: number;
            user_name?: string;
            email?: string;
            phone_number?: string;
            type_id: number;
            location_id: number;
            description: string;
            solution: string;
            has_image: number;
        },
        fetchData: {} as {
            ID?: number;
            CODE?: string;
            STATUS_EN?: string;
            STATUS_MN?: string;
            USER_ID?: number | null;
            USER_NAME?: string | null;
            EMAIL?: string | null;
            PHONE_NUMBER?: string | null;
            TYPE_ID: number;
            LOCATION_ID: number;
            DESCRIPTION: string;
            SOLUTION?: string;
            DATE_CREATED?: Date;
            HAS_IMAGE?: number;
        }
    };

    public id?: number;
    public code?: string;
    public statusEn: 'Sent' | 'On it' | 'Solved' | 'Rejected';
    public statusMn: 'Илгээгдсэн' | 'Ажиллаж байна' | 'Шийдэгдсэн' | 'Татгалзсан';
    public user_id?: number | null;
    public user_name?: string | null;
    public email?: string | null;
    public phone_number?: string | null;
    public type_id: number;
    public location_id: number;
    public description: string;
    public solution: string;
    public date_created?: Date;
    public has_image: number;
    // joined columns
    public type_name_en?: string | null;
    public type_name_mn?: string | null;
    public location_name_en?: string | null;
    public location_name_mn?: string | null;
    public is_response_confirmed?: number | null;
    public response_body?: string | null;
    public is_private?: number;
    public date_updated?: Date | null;

    constructor(data: IHazardData, joined?: IHazardJoinedData) {
        this.id = data.id;
        this.code = data.code;
        this.statusEn = data.statusEn;
        this.statusMn = data.statusMn;
        this.user_id = data.user_id;
        this.user_name = data.user_name;
        this.email = data.email;
        this.phone_number = data.phone_number;
        this.type_id = data.type_id;
        this.location_id = data.location_id;
        this.description = data.description;
        this.solution = data.solution;
        this.date_created = data.date_created;
        this.has_image = data.has_image;
        // Assign joined fields if present
        if (joined) {
            this.type_name_en = joined.type_name_en ?? null;
            this.type_name_mn = joined.type_name_mn ?? null;
            this.location_name_en = joined.location_name_en ?? null;
            this.location_name_mn = joined.location_name_mn ?? null;
            this.is_response_confirmed = joined.is_response_confirmed ?? null;
            this.response_body = joined.response_body ?? null;
            this.is_private = joined.is_private !== null ? joined.is_private : undefined;
            this.date_updated = joined.date_updated ?? null;
        }
    }

    validate(): { isValid: boolean; errors: string[] } {
        const result = HazardSchema.safeParse(this);
        
        if (result.success) {
            return { isValid: true, errors: [] };
        }
        
        const errorMessages = result.error.issues.map(issue => issue.message);
        return { isValid: false, errors: errorMessages };
    }

    toDatabaseFormat(): typeof Hazard.modelFor.fetchData {
        return {
            ID: this.id,
            CODE: this.code,
            STATUS_EN: this.statusEn,
            STATUS_MN: this.statusMn,
            USER_ID: this.user_id,
            USER_NAME: this.user_name,
            EMAIL: this.email,
            PHONE_NUMBER: this.phone_number,
            TYPE_ID: this.type_id,
            LOCATION_ID: this.location_id,
            DESCRIPTION: this.description,
            SOLUTION: this.solution,
            DATE_CREATED: this.date_created,
            HAS_IMAGE: this.has_image
        };
    }

    toJSON(isIncludeReference: boolean): IHazardData & IHazardJoinedData {
        if(isIncludeReference !== true){
            return {
                id: this.id,
                code: this.code,
                statusEn: this.statusEn,
                statusMn: this.statusMn,
                user_id: this.user_id,
                user_name: this.user_name,
                email: this.email,
                phone_number: this.phone_number,
                type_id: this.type_id,
                location_id: this.location_id,
                description: this.description,
                solution: this.solution,
                date_created: this.date_created,
                has_image: this.has_image,
            }
        }else{
            return {
                id: this.id,
                code: this.code,
                statusEn: this.statusEn,
                statusMn: this.statusMn,
                user_id: this.user_id,
                user_name: this.user_name,
                email: this.email,
                phone_number: this.phone_number,
                type_id: this.type_id,
                location_id: this.location_id,
                description: this.description,
                solution: this.solution,
                date_created: this.date_created,
                has_image: this.has_image,
                // joined fields
                type_name_en: this.type_name_en,
                type_name_mn: this.type_name_mn,
                location_name_en: this.location_name_en,
                location_name_mn: this.location_name_mn,
                is_response_confirmed: this.is_response_confirmed,
                response_body: this.response_body,
                is_private: this.is_private,
                date_updated: this.date_updated,
            };
        }
    }

    static fromDatabase(row: any): Hazard {
        // Validate core fields
        const core = HazardSchema.parse({
            id: row.ID,
            code: row.CODE,
            statusEn: row.STATUS_EN as 'Sent' | 'On it' | 'Solved' | 'Rejected',
            statusMn: row.STATUS_MN as 'Илгээгдсэн' | 'Ажиллаж байна' | 'Шийдэгдсэн' | 'Татгалзсан',
            user_id: row.USER_ID,
            user_name: row.USER_NAME,
            email: row.EMAIL,
            phone_number: row.PHONE_NUMBER,
            type_id: row.TYPE_ID,
            location_id: row.LOCATION_ID,
            description: row.DESCRIPTION,
            solution: row.SOLUTION,
            date_created: row.DATE_CREATED,
            has_image: row.HAS_IMAGE
        });
        // Validate joined fields
        const joined = HazardJoinedSchema.safeParse({
            type_name_en: row.TYPE_NAME_EN ?? null,
            type_name_mn: row.TYPE_NAME_MN ?? null,
            is_private: row.IS_PRIVATE ?? null,
            location_name_en: row.LOCATION_NAME_EN ?? null,
            location_name_mn: row.LOCATION_NAME_MN ?? null,
            is_response_confirmed: row.IS_RESPONSE_CONFIRMED ?? null,
            response_body: row.RESPONSE_BODY ?? null,
            date_updated: row.DATE_UPDATED ?? null,
            has_image: row.HAS_IMAGE ?? null
        });
        return new Hazard(core, joined.success ? joined.data : undefined);
    }

    static fromRequestData(request: typeof Hazard.modelFor.createRequest): Hazard {
        return new Hazard({
            statusEn: 'Sent',
            statusMn: 'Илгээгдсэн',
            user_id: request.user_id,
            user_name: request.user_name,
            email: request.email,
            phone_number: request.phone_number,
            type_id: request.type_id,
            location_id: request.location_id,
            description: request.description,
            solution: request.solution,
            has_image: request.has_image
        });
    }
}

export type HazardCreateRequest = typeof Hazard.modelFor.createRequest;
export type HazardData = IHazardData;
export type HazardOracleFormat = typeof Hazard.modelFor.fetchData;
